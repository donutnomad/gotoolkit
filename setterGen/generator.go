package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"unicode"
)

// generateSetterFile 生成setter文件
func generateSetterFile(filename string, structInfo *StructInfo, enableClean bool) error {
	var filteredFields []FieldInfo

	if enableClean {
		// 分析包内方法使用情况
		dir := filepath.Dir(filename)
		usedMethods, err := analyzePackageUsage(dir, filename, structInfo)
		if err != nil {
			fmt.Printf("警告: 分析方法使用情况失败: %v\n", err)
			// 如果分析失败，生成所有方法
			filteredFields = structInfo.Fields
		} else {
			// 过滤未使用的字段
			filteredFields = filterUnusedFields(structInfo, usedMethods)

			// 如果没有使用的方法，至少保留所有字段（首次生成的情况）
			if len(filteredFields) == 0 {
				filteredFields = structInfo.Fields
			}
		}
	} else {
		// 不启用清理，生成所有字段
		filteredFields = structInfo.Fields
	}

	var sb strings.Builder

	// 添加代码生成注释
	sb.WriteString("// Code generated by setterGen. DO NOT EDIT.\n\n")

	// 写入包声明
	sb.WriteString(fmt.Sprintf("package %s\n\n", structInfo.PackageName))

	// 写入导入
	imports := getRequiredImports(structInfo)
	if len(imports) > 0 {
		sb.WriteString("import (\n")
		for _, imp := range imports {
			sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		sb.WriteString(")\n\n")
	}

	// 生成Patch结构体
	sb.WriteString(generatePatchStructWithFields(structInfo, filteredFields))
	sb.WriteString("\n")

	// 生成setter方法
	sb.WriteString(generateSetterMethodsWithFields(structInfo, filteredFields))

	// 写入文件
	err := os.WriteFile(filename, []byte(sb.String()), 0644)
	if err != nil {
		return err
	}

	// 运行goimports格式化生成的文件
	cmd := exec.Command("goimports", "-w", filename)
	if err := cmd.Run(); err != nil {
		// 如果goimports失败，不返回错误，只是跳过格式化
		fmt.Printf("警告: 运行goimports失败: %v\n", err)
	}

	// 输出统计信息
	if enableClean {
		totalFields := 0
		for _, field := range structInfo.Fields {
			if strings.ToLower(field.Name) != "patch" {
				totalFields++
			}
		}
		usedCount := len(filteredFields)
		for _, field := range filteredFields {
			if strings.ToLower(field.Name) == "patch" {
				usedCount--
			}
		}

		fmt.Printf("生成setter方法: %d/%d (跳过了%d个未使用的方法)\n",
			usedCount, totalFields, totalFields-usedCount)
	}

	return nil
}

// getRequiredImports 获取需要的导入
func getRequiredImports(structInfo *StructInfo) []string {
	importSet := make(map[string]bool)

	// 检查是否需要导入github.com/samber/mo
	needsMo := false
	for _, field := range structInfo.Fields {
		// 跳过patch字段本身
		if strings.ToLower(field.Name) == "patch" {
			continue
		}
		needsMo = true
		break
	}

	if needsMo {
		importSet["github.com/samber/mo"] = true
	}

	// 收集其他可能需要的导入
	for _, field := range structInfo.Fields {
		if strings.Contains(field.Type, "time.Time") {
			importSet["time"] = true
		}
		if strings.Contains(field.Type, "types.") {
			// 这里可以根据实际项目情况调整
			for _, imp := range structInfo.Imports {
				if strings.Contains(imp, "types") {
					importSet[imp] = true
					break
				}
			}
		}
	}

	var imports []string
	for imp := range importSet {
		imports = append(imports, imp)
	}
	return imports
}

// generatePatchStruct 生成Patch结构体
func generatePatchStruct(structInfo *StructInfo) string {
	return generatePatchStructWithFields(structInfo, structInfo.Fields)
}

// generatePatchStructWithFields 使用指定字段生成Patch结构体
func generatePatchStructWithFields(structInfo *StructInfo, fields []FieldInfo) string {
	var sb strings.Builder

	patchName := structInfo.Name + "Patch"
	sb.WriteString(fmt.Sprintf("type %s struct {\n", patchName))

	for _, field := range fields {
		// 跳过patch字段本身
		if strings.ToLower(field.Name) == "patch" {
			continue
		}

		fieldType := field.Type
		// 使用mo.Option[Type]格式，如果原字段是指针类型，保持指针类型在Option内部
		optionType := fmt.Sprintf("mo.Option[%s]", fieldType)

		sb.WriteString(fmt.Sprintf("\t%s %s\n", field.Name, optionType))
	}

	sb.WriteString("}")
	return sb.String()
}

// generateSetterMethods 生成setter方法
func generateSetterMethods(structInfo *StructInfo) string {
	return generateSetterMethodsWithFields(structInfo, structInfo.Fields)
}

// generateSetterMethodsWithFields 使用指定字段生成setter方法
func generateSetterMethodsWithFields(structInfo *StructInfo, fields []FieldInfo) string {
	var sb strings.Builder

	receiverName := strings.ToLower(string(structInfo.Name[0]))

	for _, field := range fields {
		// 跳过patch字段本身
		if strings.ToLower(field.Name) == "patch" {
			continue
		}

		methodName := "set" + field.Name
		paramName := lowerFirst(field.Name)

		sb.WriteString(fmt.Sprintf("func (%s *%s) %s(%s %s) {\n",
			receiverName, structInfo.Name, methodName, paramName, field.Type))

		// 设置字段值
		sb.WriteString(fmt.Sprintf("\t%s.%s = %s\n", receiverName, field.Name, paramName))

		// 设置patch字段，统一使用mo.Some()
		sb.WriteString(fmt.Sprintf("\t%s.patch.%s = mo.Some(%s)\n", receiverName, field.Name, paramName))

		sb.WriteString("}\n\n")
	}

	return sb.String()
}

// lowerFirst 将首字母转换为小写
func lowerFirst(s string) string {
	if s == "" {
		return s
	}
	r := []rune(s)
	r[0] = unicode.ToLower(r[0])
	return string(r)
}

// analyzePackageUsage 分析包内setter方法的使用情况
func analyzePackageUsage(dir string, setterFileName string, structInfo *StructInfo) (map[string]bool, error) {
	usedMethods := make(map[string]bool)

	// 获取所有生成的setter方法名
	var setterMethods []string
	for _, field := range structInfo.Fields {
		if strings.ToLower(field.Name) == "patch" {
			continue
		}
		setterMethods = append(setterMethods, "set"+field.Name)
	}

	// 遍历目录中的所有Go文件
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// 跳过非Go文件、测试文件和生成的setter文件本身
		if !strings.HasSuffix(path, ".go") ||
			strings.HasSuffix(path, "_test.go") ||
			path == setterFileName {
			return nil
		}

		// 解析文件
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return nil // 跳过解析失败的文件
		}

		// 检查包名是否匹配
		if node.Name.Name != structInfo.PackageName {
			return nil
		}

		// 遍历AST查找方法调用
		ast.Inspect(node, func(n ast.Node) bool {
			switch x := n.(type) {
			case *ast.CallExpr:
				if sel, ok := x.Fun.(*ast.SelectorExpr); ok {
					methodName := sel.Sel.Name
					// 检查是否是我们生成的setter方法
					for _, setterMethod := range setterMethods {
						if methodName == setterMethod {
							usedMethods[methodName] = true
						}
					}
				}
			}
			return true
		})

		return nil
	})

	return usedMethods, err
}

// filterUnusedFields 根据使用情况过滤字段
func filterUnusedFields(structInfo *StructInfo, usedMethods map[string]bool) []FieldInfo {
	var filteredFields []FieldInfo

	for _, field := range structInfo.Fields {
		// 跳过patch字段本身
		if strings.ToLower(field.Name) == "patch" {
			continue
		}

		methodName := "set" + field.Name
		if usedMethods[methodName] {
			filteredFields = append(filteredFields, field)
		}
	}

	return filteredFields
}
