package main

import (
	"fmt"
	"maps"
	"slices"
	"strings"

	"github.com/donutnomad/gotoolkit/automap"
	"github.com/donutnomad/gotoolkit/internal/gormparse"
	"github.com/donutnomad/gotoolkit/internal/utils"
	"github.com/samber/lo"
)

var name = "gormgen"

type GormModelInfo = gormparse.GormModelInfo

// GenPatch 生成多个结构体的GORM Patch文件
func GenPatch(filename string, gormModels []*GormModelInfo, mapperMethod [][2]string) error {
	if len(gormModels) == 0 {
		return fmt.Errorf("没有模型需要生成")
	}
	g := PatchGen{}
	var sb strings.Builder
	g.GenPkg(&sb, gormModels)
	if *patch {
		g.GenImports(&sb, gormModels)
		g.GenBody(&sb, gormModels)
	} else if *patch2 {
		sb.WriteString("\n// ============ Patch ============\n\n")
		for _, item := range mapperMethod {
			_, code, err := automap.Generate(item[0], "ToPatch", automap.WithFileContext(item[1]))
			if err != nil {
				panic("\"生成patch.ToPatch代码失败: %v\", err")
			}
			sb.WriteString(code)
			sb.WriteString("\n")
		}
	}

	return utils.WriteFormat(filename, []byte(sb.String()))
}

type PatchGen struct {
}

func (g PatchGen) GenPkg(sb *strings.Builder, gormModels []*GormModelInfo) {
	// 添加代码生成注释
	sb.WriteString(fmt.Sprintf("// Code generated by %s. DO NOT EDIT.\n\n", name))

	// 写入包声明 - 使用第一个模型的包名
	sb.WriteString(fmt.Sprintf("package %s\n\n", gormModels[0].PackageName))
}
func (g PatchGen) GetImports(gormModels []*gormparse.GormModelInfo) []string {
	var ret []string
	allImports := make(map[string]bool)
	for _, gormModel := range gormModels {
		imports := getGormRequiredImports(gormModel)
		for _, imp := range imports {
			allImports[imp] = true
		}
	}
	ret = append(ret, slices.Collect(maps.Keys(allImports))...)
	return lo.Uniq(ret)
}
func (g PatchGen) GenImports(sb *strings.Builder, gormModels []*GormModelInfo) {
	allImports := g.GetImports(gormModels)
	// 写入导入
	if len(allImports) > 0 {
		sb.WriteString("import (\n")
		for _, imp := range allImports {
			sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		sb.WriteString(")\n\n")
	}
}
func (g PatchGen) GenBody(sb *strings.Builder, gormModels []*GormModelInfo) {
	// 为每个模型生成代码
	for i, gormModel := range gormModels {
		if i > 0 {
			sb.WriteString("\n")
		}
		// 生成Patch结构体
		sb.WriteString(generateGormPatchStruct(gormModel))
		sb.WriteString("\n\n")

		// 生成Build方法
		sb.WriteString(generateBuildMethod(gormModel))
		sb.WriteString("\n\n")

		// 生成Add方法
		sb.WriteString(generateAddMethod(gormModel))
		sb.WriteString("\n\n")

		// 生成setter方法
		sb.WriteString(generateFieldSetterMethods(gormModel))
	}
}

// getGormRequiredImports 获取GORM Patch需要的导入
func getGormRequiredImports(gormModel *GormModelInfo) []string {
	importSet := make(map[string]bool)

	// 始终需要mo包
	importSet["github.com/samber/mo"] = true

	// 始终需要clause包（为了Add方法）
	importSet["gorm.io/gorm/clause"] = true

	// 收集其他可能需要的导入
	for _, field := range gormModel.Fields {
		if strings.Contains(field.Type, "time.Time") {
			importSet["time"] = true
		}
		if strings.Contains(field.Type, "gorm.DeletedAt") {
			importSet["gorm.io/gorm"] = true
		}
		if strings.Contains(field.Type, "datatypes.JSONType") || strings.Contains(field.Type, "datatypes.JSONSlice") {
			importSet["gorm.io/datatypes"] = true
		}
		// 可以根据需要添加更多导入检测
	}

	var imports []string
	for imp := range importSet {
		imports = append(imports, imp)
	}
	return imports
}

// generateGormPatchStruct 生成GORM Patch结构体
func generateGormPatchStruct(gormModel *GormModelInfo) string {
	var sb strings.Builder

	patchName := gormModel.Name + "Patch"
	sb.WriteString(fmt.Sprintf("type %s struct {", patchName))

	if len(gormModel.Fields) > 0 {
		sb.WriteString("\n")
		for _, field := range gormModel.Fields {
			optionType := fmt.Sprintf("mo.Option[%s]", field.Type)

			// 生成字段定义
			fieldDef := fmt.Sprintf("\t%s %s", field.Name, optionType)

			// 如果字段来自嵌入结构体，添加来源注释
			if field.SourceType != "" {
				fieldDef += fmt.Sprintf(" // from %s", field.SourceType)
			}

			sb.WriteString(fieldDef + "\n")
		}
	}

	// 添加other字段
	sb.WriteString("\tother map[string]any\n")

	sb.WriteString("}")
	return sb.String()
}

// generateBuildMethod 生成Build方法
func generateBuildMethod(gormModel *GormModelInfo) string {
	var sb strings.Builder

	receiverName := strings.ToLower(string(gormModel.Name[0]))
	patchName := gormModel.Name + "Patch"

	sb.WriteString(fmt.Sprintf("func (%s %s) Build() map[string]any {", receiverName, patchName))

	if len(gormModel.Fields) == 0 {
		sb.WriteString("\n\treturn make(map[string]any)\n}")
		return sb.String()
	}

	// 计算可能的最大容量（字段数量 + other字段中的项目）
	fieldCount := len(gormModel.Fields)
	sb.WriteString(fmt.Sprintf("\n\tvar ret = make(map[string]any, %d+len(%s.other))\n", fieldCount, receiverName))

	for _, field := range gormModel.Fields {
		sb.WriteString(fmt.Sprintf("\tif %s.%s.IsPresent() {\n", receiverName, field.Name))
		sb.WriteString(fmt.Sprintf("\t\tret[\"%s\"] = %s.%s.MustGet()\n", field.ColumnName, receiverName, field.Name))
		sb.WriteString("\t}\n")
	}

	// 添加other字段的合并逻辑
	sb.WriteString(fmt.Sprintf("\tfor k, v := range %s.other {\n", receiverName))
	sb.WriteString("\t\tret[k] = v\n")
	sb.WriteString("\t}\n")

	sb.WriteString("\treturn ret\n}")
	return sb.String()
}

// generateAddMethod 生成Add方法
func generateAddMethod(gormModel *GormModelInfo) string {
	var sb strings.Builder

	receiverName := strings.ToLower(string(gormModel.Name[0]))
	patchName := gormModel.Name + "Patch"

	sb.WriteString(fmt.Sprintf("func (%s *%s) Add(key string, value clause.Expr) *%s {", receiverName, patchName, patchName))
	sb.WriteString(fmt.Sprintf("\n\tif %s.other == nil {", receiverName))
	sb.WriteString(fmt.Sprintf("\n\t\t%s.other = make(map[string]any)", receiverName))
	sb.WriteString("\n\t}")
	sb.WriteString(fmt.Sprintf("\n\t%s.other[key] = value", receiverName))
	sb.WriteString(fmt.Sprintf("\n\treturn %s", receiverName))
	sb.WriteString("\n}")

	return sb.String()
}

// generateFieldSetterMethods 生成字段setter方法
func generateFieldSetterMethods(gormModel *GormModelInfo) string {
	var sb strings.Builder

	receiverName := strings.ToLower(string(gormModel.Name[0]))
	patchName := gormModel.Name + "Patch"

	for _, field := range gormModel.Fields {
		methodName := "set" + field.Name
		paramName := safeParamNameForGorm(field.Name)

		// 先检查JSONSlice，因为它更具体
		if isJSONSliceType(field.Type) {
			// 提取泛型参数T，参数类型为[]T
			innerType := extractJSONSliceParameter(field.Type)
			sliceType := "[]" + innerType
			sb.WriteString(fmt.Sprintf("func (%s *%s) %s(%s %s) *%s {\n", receiverName, patchName, methodName, paramName, sliceType, patchName))
			sb.WriteString(fmt.Sprintf("\t%s.%s = mo.Some(datatypes.NewJSONSlice(%s))\n", receiverName, field.Name, paramName))
		} else if isJSONType2(field.Type) {
			// 提取泛型参数T
			innerType := extractJSONTypeParameter(field.Type)
			sb.WriteString(fmt.Sprintf("func (%s *%s) %s(%s %s) *%s {\n", receiverName, patchName, methodName, paramName, innerType, patchName))
			sb.WriteString(fmt.Sprintf("\t%s.%s = mo.Some(datatypes.NewJSONType(%s))\n", receiverName, field.Name, paramName))
		} else {
			// 普通类型
			sb.WriteString(fmt.Sprintf("func (%s *%s) %s(%s %s) *%s {\n", receiverName, patchName, methodName, paramName, field.Type, patchName))
			sb.WriteString(fmt.Sprintf("\t%s.%s = mo.Some(%s)\n", receiverName, field.Name, paramName))
		}

		sb.WriteString(fmt.Sprintf("\treturn %s\n", receiverName))
		sb.WriteString("}\n\n")
	}

	return sb.String()
}

// isJSONType 检查类型是否是datatypes.JSONType[T]格式
func isJSONType2(fieldType string) bool {
	return strings.HasPrefix(fieldType, "datatypes.JSONType[") && strings.HasSuffix(fieldType, "]")
}

// isJSONSliceType 检查类型是否是datatypes.JSONSlice[T]格式
func isJSONSliceType(fieldType string) bool {
	return strings.HasPrefix(fieldType, "datatypes.JSONSlice[") && strings.HasSuffix(fieldType, "]")
}

// extractJSONTypeParameter 从datatypes.JSONType[T]中提取T
func extractJSONTypeParameter(fieldType string) string {
	if !isJSONType2(fieldType) {
		return fieldType
	}

	// 去除"datatypes.JSONType["前缀和"]"后缀
	start := len("datatypes.JSONType[")
	end := len(fieldType) - 1
	return fieldType[start:end]
}

// extractJSONSliceParameter 从datatypes.JSONSlice[T]中提取T
func extractJSONSliceParameter(fieldType string) string {
	if !isJSONSliceType(fieldType) {
		return fieldType
	}

	// 去除"datatypes.JSONSlice["前缀和"]"后缀
	start := len("datatypes.JSONSlice[")
	end := len(fieldType) - 1
	return fieldType[start:end]
}

// isGoKeywordForGorm 检查是否是Go关键词
func isGoKeywordForGorm(s string) bool {
	keywords := map[string]bool{
		"break": true, "case": true, "chan": true, "const": true, "continue": true,
		"default": true, "defer": true, "else": true, "fallthrough": true, "for": true,
		"func": true, "go": true, "goto": true, "if": true, "import": true,
		"interface": true, "map": true, "package": true, "range": true, "return": true,
		"select": true, "struct": true, "switch": true, "type": true, "var": true,
	}
	return keywords[s]
}

// safeParamNameForGorm 生成安全的参数名（避免Go关键词）
func safeParamNameForGorm(fieldName string) string {
	paramName := strings.ToLower(fieldName)
	if isGoKeywordForGorm(paramName) {
		return paramName + "Val"
	}
	return paramName
}
