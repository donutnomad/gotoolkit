package main

import (
	"fmt"
	"maps"
	"slices"
	"strings"

	"github.com/donutnomad/gotoolkit/automap"
	"github.com/donutnomad/gotoolkit/internal/gormparse"
	"github.com/donutnomad/gotoolkit/internal/utils"
	"github.com/samber/lo"
)

func GenQuery(filename string, models []*gormparse.GormModelInfo) error {
	if len(models) == 0 {
		return fmt.Errorf("[gormgen] 没有模型需要生成")
	}
	g := ModelGen{}

	var builder strings.Builder
	g.GenPkg(&builder, models)
	g.GenImports(&builder, models)
	g.GenBody(&builder, models)

	return utils.WriteFormat(filename, []byte(builder.String()))
}

// genQueryAndPatch 生成包含query和patch的合并文件
func genQueryAndPatch(filename string, models []*gormparse.GormModelInfo, mapperMethod [][2]string) error {
	if len(models) == 0 {
		return fmt.Errorf("[gormgen] 没有模型需要生成")
	}

	var sb strings.Builder

	g := ModelGen{}
	g2 := PatchGen{}
	g.GenPkg(&sb, models)

	imports := g.GetImports(models)
	if *patch {
		imports = append(imports, g2.GetImports(models)...)
	} else if *patch2 {
	}
	imports = lo.Uniq(imports)
	if len(imports) > 0 {
		sb.WriteString("import (\n")
		for _, imp := range imports {
			sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		sb.WriteString(")\n\n")
	}

	g.GenBody(&sb, models)
	if *patch {
		sb.WriteString("\n// ============ Patch Structures ============\n\n")
		g2.GenBody(&sb, models)
	} else if *patch2 {
		sb.WriteString("\n// ============ Patch ============\n\n")
		for _, item := range mapperMethod {
			_, code, err := automap.Generate(item[0], "ToPatch", automap.WithFileContext(item[1]))
			if err != nil {
				panic("\"生成patch.ToPatch代码失败: %v\", err")
			}
			sb.WriteString(code)
			sb.WriteString("\n")
		}
	}

	return utils.WriteFormat(filename, []byte(sb.String()))
}

type ModelGen struct {
}

func (g *ModelGen) GenPkg(sb *strings.Builder, gormModels []*gormparse.GormModelInfo) {
	sb.WriteString(fmt.Sprintf("// Code generated by %s. DO NOT EDIT.\n", name))
	sb.WriteString(fmt.Sprintf("package %s\n\n", gormModels[0].PackageName))
}
func (g *ModelGen) GetImports(gormModels []*gormparse.GormModelInfo) []string {
	ret := []string{
		"github.com/donutnomad/gsql",
		"github.com/donutnomad/gsql/field",
	}
	allImports := make(map[string]bool)
	for _, gormModel := range gormModels {
		imports := getGormRequiredImports(gormModel)
		for _, imp := range imports {
			allImports[imp] = true
		}
	}
	ret = append(ret, slices.Collect(maps.Keys(allImports))...)
	return lo.Uniq(ret)
}
func (g *ModelGen) GenImports(sb *strings.Builder, gormModels []*gormparse.GormModelInfo) {
	sb.WriteString("import (\n")
	for _, imp := range g.GetImports(gormModels) {
		sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
	}
	sb.WriteString(")\n\n")
}
func (g *ModelGen) GenBody(sb *strings.Builder, gormModels []*gormparse.GormModelInfo) {
	// 为每个模型生成代码
	for i, model := range gormModels {
		if i > 0 {
			sb.WriteString("\n") // 模型之间添加空行
		}
		sb.WriteString(generateModelCode(model))
	}
}

// generateModelCode 生成单个模型的代码
func generateModelCode(model *gormparse.GormModelInfo) string {
	var builder strings.Builder

	rawModelName := model.Name
	modelName := rawModelName
	if strings.ToLower(modelName[len(modelName)-2:]) == "po" {
		modelName = modelName[:len(modelName)-2]
	}
	// 处理字段名称冲突问题
	for idx, f := range model.Fields {
		if slices.Contains([]string{
			"TableName",
			"Alias",
			"WithTable",
			"As",
			"ModelType",
			"ModelTypeAny",
			"AllFields",
			"Star",
		}, f.Name) {
			f.Name += "T"
		}
		model.Fields[idx] = f
	}

	// 生成泛型表结构
	structName := model.Prefix + modelName + "SchemaType"
	builder.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	// 生成字段
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue
		}
		builder.WriteString(fmt.Sprintf("\t%s %s\n", field.Name, fieldType))
	}
	builder.WriteString(fmt.Sprintf("\t%s %s\n", "fieldType", rawModelName))

	// 添加私有字段
	builder.WriteString("\talias     string\n")
	builder.WriteString("\ttableName string\n")
	builder.WriteString("}\n\n")

	// 生成TableName方法
	builder.WriteString(fmt.Sprintf("func (t %s) TableName() string {\n", structName))
	builder.WriteString("\treturn t.tableName\n")
	builder.WriteString("}\n\n")
	// 生成Alias方法
	builder.WriteString(fmt.Sprintf("func (t %s) Alias() string {\n", structName))
	builder.WriteString("\treturn t.alias\n")
	builder.WriteString("}\n\n")

	// 生成WithTable方法
	builder.WriteString(fmt.Sprintf("func (t *%s) WithTable(tableName string) {\n", structName))
	builder.WriteString("\ttn := gsql.TableName(tableName)\n")

	// 为每个字段调用WithTable
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue
		}
		builder.WriteString(fmt.Sprintf("\tt.%s = t.%s.WithTable(&tn)\n", field.Name, field.Name))
	}

	builder.WriteString("}\n\n")

	// 生成As方法
	builder.WriteString(fmt.Sprintf("func (t %s) As(alias string) %s {\n", structName, structName))
	builder.WriteString("\tvar ret = t\n")
	builder.WriteString("\tret.alias = alias\n")
	builder.WriteString("\tret.WithTable(alias)\n")
	builder.WriteString("\treturn ret\n")
	builder.WriteString("}\n\n")

	// 生成ModelType方法
	builder.WriteString(fmt.Sprintf("func (t %s) ModelType() *%s {\n", structName, rawModelName))
	builder.WriteString("\treturn &t.fieldType\n")
	builder.WriteString("}\n\n")

	// 生成ModelTypeAny方法
	builder.WriteString(fmt.Sprintf("func (t %s) ModelTypeAny() any {\n", structName))
	builder.WriteString("\treturn &t.fieldType\n")
	builder.WriteString("}\n\n")

	// 生成AllFields方法
	builder.WriteString(fmt.Sprintf("func (t %s) AllFields() field.BaseFields {\n", structName))
	builder.WriteString("\treturn field.BaseFields{\n")
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue
		}
		builder.WriteString(fmt.Sprintf("\tt.%s,\n", field.Name))
	}
	builder.WriteString("\t}\n")
	builder.WriteString("}\n\n")

	// 生成Star()方法
	builder.WriteString(fmt.Sprintf("func (t %s) Star() field.IField {\n", structName))
	builder.WriteString("\tif t.alias != \"\" {\n")
	builder.WriteString("\treturn gsql.StarWith(t.alias)\n")
	builder.WriteString("\t}\n")
	builder.WriteString("\treturn gsql.StarWith(t.tableName)\n")
	builder.WriteString("}\n\n")

	// 生成变量实例
	varName := modelName + "Schema"
	builder.WriteString(fmt.Sprintf("var %s = %s{\n", varName, structName))
	builder.WriteString(fmt.Sprintf("\ttableName: \"%s\",\n", model.TableName))

	// 初始化所有字段
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue
		}
		constructor := getFieldConstructor(fieldType)
		flags := getFieldFlags(field.Tag)
		if flags != "" {
			builder.WriteString(fmt.Sprintf("\t%s: %s(\"%s\", \"%s\", %s),\n", field.Name, constructor, model.TableName, field.ColumnName, flags))
		} else {
			builder.WriteString(fmt.Sprintf("\t%s: %s(\"%s\", \"%s\"),\n", field.Name, constructor, model.TableName, field.ColumnName))
		}
	}
	builder.WriteString(fmt.Sprintf("\t%s: %s{},\n", "fieldType", rawModelName))

	builder.WriteString("}\n")

	return builder.String()
}
