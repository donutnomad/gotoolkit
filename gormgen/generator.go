package main

import (
	"fmt"
	"slices"
	"strings"

	"github.com/donutnomad/gotoolkit/internal/gormparse"
	"github.com/donutnomad/gotoolkit/internal/utils"
)

// generateGormQueryFileForMultiple 生成多个模型的GORM查询文件
func generateGormQueryFileForMultiple(filename string, models []*gormparse.GormModelInfo) error {
	if len(models) == 0 {
		return fmt.Errorf("没有模型需要生成")
	}

	var builder strings.Builder
	builder.WriteString("// Code generated by gormgen. DO NOT EDIT.\n")

	// 包声明 - 使用第一个模型的包名
	builder.WriteString(fmt.Sprintf("package %s\n\n", models[0].PackageName))

	// 导入
	builder.WriteString("import (\n")
	builder.WriteString("\t\"github.com/donutnomad/gotoolkit/lib/gsql/field\"\n")
	builder.WriteString("\tgsql \"github.com/donutnomad/gotoolkit/lib/gsql\"\n")
	builder.WriteString(")\n\n")

	// 为每个模型生成代码
	for i, model := range models {
		if i > 0 {
			builder.WriteString("\n") // 模型之间添加空行
		}
		builder.WriteString(generateModelCode(model))
	}

	return utils.WriteFormat(filename, []byte(builder.String()))
}

// generateModelCode 生成单个模型的代码
func generateModelCode(model *gormparse.GormModelInfo) string {
	var builder strings.Builder

	rawModelName := model.Name
	modelName := rawModelName
	if strings.ToLower(modelName[len(modelName)-2:]) == "po" {
		modelName = modelName[:len(modelName)-2]
	}
	// 处理字段名称冲突问题
	for idx, f := range model.Fields {
		if slices.Contains([]string{
			"TableName",
			"Alias",
			"WithTable",
			"As",
			"ModelType",
			"ModelTypeAny",
			"AllFields",
			"Star",
		}, f.Name) {
			f.Name += "T"
		}
		model.Fields[idx] = f
	}

	// 生成泛型表结构
	structName := model.Prefix + modelName + "SchemaType"
	builder.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	// 生成字段
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue
		}
		builder.WriteString(fmt.Sprintf("\t%s %s\n", field.Name, fieldType))
	}
	builder.WriteString(fmt.Sprintf("\t%s %s\n", "fieldType", rawModelName))

	// 添加私有字段
	builder.WriteString("\talias     string\n")
	builder.WriteString("\ttableName string\n")
	builder.WriteString("}\n\n")

	// 生成TableName方法
	builder.WriteString(fmt.Sprintf("func (t %s) TableName() string {\n", structName))
	builder.WriteString("\treturn t.tableName\n")
	builder.WriteString("}\n\n")
	// 生成Alias方法
	builder.WriteString(fmt.Sprintf("func (t %s) Alias() string {\n", structName))
	builder.WriteString("\treturn t.alias\n")
	builder.WriteString("}\n\n")

	// 生成WithTable方法
	builder.WriteString(fmt.Sprintf("func (t *%s) WithTable(tableName string) {\n", structName))
	builder.WriteString("\ttn := gsql.TableName(tableName)\n")

	// 为每个字段调用WithTable
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue
		}
		builder.WriteString(fmt.Sprintf("\tt.%s = t.%s.WithTable(&tn)\n", field.Name, field.Name))
	}

	builder.WriteString("}\n\n")

	// 生成As方法
	builder.WriteString(fmt.Sprintf("func (t %s) As(alias string) %s {\n", structName, structName))
	builder.WriteString(fmt.Sprintf("\tvar ret = t\n"))
	builder.WriteString("\tret.alias = alias\n")
	builder.WriteString("\tret.WithTable(alias)\n")
	builder.WriteString("\treturn ret\n")
	builder.WriteString("}\n\n")

	// 生成ModelType方法
	builder.WriteString(fmt.Sprintf("func (t %s) ModelType() *%s {\n", structName, rawModelName))
	builder.WriteString("\treturn &t.fieldType\n")
	builder.WriteString("}\n\n")

	// 生成ModelTypeAny方法
	builder.WriteString(fmt.Sprintf("func (t %s) ModelTypeAny() any {\n", structName))
	builder.WriteString("\treturn &t.fieldType\n")
	builder.WriteString("}\n\n")

	// 生成AllFields方法
	builder.WriteString(fmt.Sprintf("func (t %s) AllFields() field.BaseFields {\n", structName))
	builder.WriteString("\treturn field.BaseFields{\n")
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue
		}
		builder.WriteString(fmt.Sprintf("\tt.%s,\n", field.Name))
	}
	builder.WriteString("\t}\n")
	builder.WriteString("}\n\n")

	// 生成Star()方法
	builder.WriteString(fmt.Sprintf("func (t %s) Star() field.IField {\n", structName))
	builder.WriteString("\tif t.alias != \"\" {\n")
	builder.WriteString("\treturn gsql.StarWith(t.alias)\n")
	builder.WriteString("\t}\n")
	builder.WriteString("\treturn gsql.StarWith(t.tableName)\n")
	builder.WriteString("}\n\n")

	// 生成变量实例
	varName := modelName + "Schema"
	builder.WriteString(fmt.Sprintf("var %s = %s{\n", varName, structName))
	builder.WriteString(fmt.Sprintf("\ttableName: \"%s\",\n", model.TableName))

	// 初始化所有字段
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue
		}
		constructor := getFieldConstructor(fieldType)
		flags := getFieldFlags(field.Tag)
		if flags != "" {
			builder.WriteString(fmt.Sprintf("\t%s: %s(\"%s\", \"%s\", %s),\n", field.Name, constructor, model.TableName, field.ColumnName, flags))
		} else {
			builder.WriteString(fmt.Sprintf("\t%s: %s(\"%s\", \"%s\"),\n", field.Name, constructor, model.TableName, field.ColumnName))
		}
	}
	builder.WriteString(fmt.Sprintf("\t%s: %s{},\n", "fieldType", rawModelName))

	builder.WriteString("}\n")

	return builder.String()
}

// mapFieldType 映射字段类型到field类型
func mapFieldType(goType string) string {
	// 保留原始类型(包括包前缀)
	originalType := goType

	// JSON类型忽略
	if isJSONType(goType) {
		return fmt.Sprintf("field.Pattern[%s]", "string")
	}

	// 移除指针标记用于判断类型
	typeForCheck := strings.TrimPrefix(goType, "*")

	// 字符串类型使用Pattern
	if isStringType(typeForCheck) {
		return fmt.Sprintf("field.Pattern[%s]", originalType)
	}

	// 其他类型使用Comparable
	return fmt.Sprintf("field.Comparable[%s]", originalType)
}

// isStringType 判断是否为字符串类型
func isStringType(goType string) bool {
	stringTypes := []string{
		"string",
		"sql.NullString",
		"[]byte",
		"[]rune",
	}

	for _, t := range stringTypes {
		if goType == t {
			return true
		}
	}

	// 检查是否是text或blob类型(通常通过标签判断,这里简化处理)
	return strings.Contains(strings.ToLower(goType), "text") ||
		strings.Contains(strings.ToLower(goType), "blob")
}

// isJSONType 判断是否为JSON类型
func isJSONType(goType string) bool {
	return strings.Contains(strings.ToLower(goType), "json") ||
		goType == "datatypes.JSON" ||
		goType == "gorm.datatypes.JSON"
}

// getFieldConstructor 获取字段构造函数
func getFieldConstructor(fieldType string) string {
	if strings.Contains(fieldType, "Pattern") {
		// 提取泛型参数
		start := strings.Index(fieldType, "[")
		end := strings.LastIndex(fieldType, "]")
		if start != -1 && end != -1 {
			typeParam := fieldType[start+1 : end]
			return fmt.Sprintf("field.NewPattern[%s]", typeParam)
		}
	}

	if strings.Contains(fieldType, "Comparable") {
		// 提取泛型参数
		start := strings.Index(fieldType, "[")
		end := strings.LastIndex(fieldType, "]")
		if start != -1 && end != -1 {
			typeParam := fieldType[start+1 : end]
			return fmt.Sprintf("field.NewComparable[%s]", typeParam)
		}
	}

	return "field.NewComparable[any]"
}

// getFieldFlags 根据字段标签获取标志位
func getFieldFlags(tag string) string {
	if tag == "" {
		return ""
	}

	// 解析gorm标签
	gormTags := parseGormTag(tag)

	var flags []string

	// 检查是否为主键
	if _, hasPrimaryKey := gormTags["primarykey"]; hasPrimaryKey {
		flags = append(flags, "field.FlagPrimaryKey")
	}
	if _, hasPrimaryKey := gormTags["primaryKey"]; hasPrimaryKey {
		flags = append(flags, "field.FlagPrimaryKey")
	}

	// 检查是否有唯一索引
	if uniqueIdx, hasUniqueIndex := gormTags["uniqueIndex"]; hasUniqueIndex || uniqueIdx != "" {
		flags = append(flags, "field.FlagUniqueIndex")
	}
	if uniqueIdx, hasUniqueIndex := gormTags["unique"]; hasUniqueIndex || uniqueIdx != "" {
		flags = append(flags, "field.FlagUniqueIndex")
	}

	// 检查是否有普通索引
	if idx, hasIndex := gormTags["index"]; hasIndex || idx != "" {
		flags = append(flags, "field.FlagIndex")
	}

	// 检查是否自增
	if _, hasAutoIncrement := gormTags["autoIncrement"]; hasAutoIncrement {
		flags = append(flags, "field.FlagAutoIncrement")
	}

	if len(flags) == 0 {
		return ""
	}

	// 使用 | 组合多个标志
	return strings.Join(flags, " | ")
}

// parseGormTag 解析gorm标签
func parseGormTag(tag string) map[string]string {
	result := make(map[string]string)

	// 查找gorm标签
	start := strings.Index(tag, `gorm:"`)
	if start == -1 {
		return result
	}

	start += 6 // 跳过 gorm:"
	end := strings.Index(tag[start:], `"`)
	if end == -1 {
		return result
	}

	gormTag := tag[start : start+end]

	// 解析标签内的各个部分
	parts := strings.Split(gormTag, ";")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if strings.Contains(part, ":") {
			kv := strings.SplitN(part, ":", 2)
			if len(kv) == 2 {
				result[kv[0]] = kv[1]
			}
		} else {
			result[part] = ""
		}
	}

	return result
}
