package main

import (
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/donutnomad/gotoolkit/internal/gormparse"
)

// generateGormQueryFileForMultiple 生成多个模型的GORM查询文件
func generateGormQueryFileForMultiple(filename string, models []*gormparse.GormModelInfo) error {
	if len(models) == 0 {
		return fmt.Errorf("没有模型需要生成")
	}

	var builder strings.Builder
	builder.WriteString("// Code generated by gormgen. DO NOT EDIT.\n")

	// 包声明 - 使用第一个模型的包名
	builder.WriteString(fmt.Sprintf("package %s\n\n", models[0].PackageName))

	// 导入
	builder.WriteString("import (\n")
	builder.WriteString("\t\"github.com/donutnomad/gotoolkit/lib/gormgen/field\"\n")
	builder.WriteString("\tgsql \"github.com/donutnomad/gotoolkit/lib/gormgen\"\n")
	builder.WriteString(")\n\n")

	// 为每个模型生成代码
	for i, model := range models {
		if i > 0 {
			builder.WriteString("\n") // 模型之间添加空行
		}
		builder.WriteString(generateModelCode(model))
	}

	// 写入文件
	if err := os.WriteFile(filename, []byte(builder.String()), 0644); err != nil {
		return err
	}

	// 运行goimports格式化
	cmd := exec.Command("goimports", "-w", filename)
	if err := cmd.Run(); err != nil {
		fmt.Printf("警告: goimports失败,请手动添加必要的import: %v\n", err)
	}

	return nil
}

// generateModelCode 生成单个模型的代码
func generateModelCode(model *gormparse.GormModelInfo) string {
	var builder strings.Builder

	rawModelName := model.Name
	modelName := rawModelName
	if strings.ToLower(modelName[len(modelName)-2:]) == "po" {
		modelName = modelName[:len(modelName)-2]
	}

	// 生成泛型表结构
	structName := model.Prefix + modelName + "SchemaType"
	builder.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	// 生成字段
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue // 跳过JSON字段
		}
		builder.WriteString(fmt.Sprintf("\t%s %s\n", field.Name, fieldType))
	}
	builder.WriteString(fmt.Sprintf("\t%s %s\n", "fieldType", rawModelName))

	// 添加私有字段
	builder.WriteString("\talias     string\n")
	builder.WriteString("\ttableName string\n")
	builder.WriteString("}\n\n")

	// 生成TableName方法
	builder.WriteString(fmt.Sprintf("func (t %s) TableName() string {\n", structName))
	builder.WriteString("\treturn t.tableName\n")
	builder.WriteString("}\n\n")
	// 生成Alias方法
	builder.WriteString(fmt.Sprintf("func (t %s) Alias() string {\n", structName))
	builder.WriteString("\treturn t.alias\n")
	builder.WriteString("}\n\n")

	// 生成WithTable方法
	builder.WriteString(fmt.Sprintf("func (t *%s) WithTable(tableName string) {\n", structName))
	builder.WriteString("\ttn := gsql.TableName(tableName)\n")

	// 为每个字段调用WithTable
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue // 跳过JSON字段
		}
		builder.WriteString(fmt.Sprintf("\tt.%s = t.%s.WithTable(&tn)\n", field.Name, field.Name))
	}

	builder.WriteString("}\n\n")

	// 生成As方法
	builder.WriteString(fmt.Sprintf("func (t %s) As(alias string) %s {\n", structName, structName))
	builder.WriteString(fmt.Sprintf("\tvar ret = t\n"))
	builder.WriteString("\tret.alias = alias\n")
	builder.WriteString("\tret.WithTable(alias)\n")
	builder.WriteString("\treturn ret\n")
	builder.WriteString("}\n\n")

	// 生成ModelType方法
	builder.WriteString(fmt.Sprintf("func (t %s) ModelType() *%s {\n", structName, rawModelName))
	builder.WriteString("\treturn &t.fieldType\n")
	builder.WriteString("}\n\n")

	// 生成ModelTypeAny方法
	builder.WriteString(fmt.Sprintf("func (t %s) ModelTypeAny() any {\n", structName))
	builder.WriteString("\treturn &t.fieldType\n")
	builder.WriteString("}\n\n")

	// 生成变量实例
	varName := modelName + "Schema"
	builder.WriteString(fmt.Sprintf("var %s = %s{\n", varName, structName))
	builder.WriteString(fmt.Sprintf("\ttableName: \"%s\",\n", model.TableName))

	// 初始化所有字段
	for _, field := range model.Fields {
		fieldType := mapFieldType(field.Type)
		if fieldType == "" {
			continue // 跳过JSON字段
		}
		constructor := getFieldConstructor(fieldType)
		builder.WriteString(fmt.Sprintf("\t%s: %s(\"%s\", \"%s\"),\n", field.Name, constructor, model.TableName, field.ColumnName))
	}
	builder.WriteString(fmt.Sprintf("\t%s: %s{},\n", "fieldType", rawModelName))

	builder.WriteString("}\n")

	return builder.String()
}

// mapFieldType 映射字段类型到field类型
func mapFieldType(goType string) string {
	// JSON类型忽略
	if isJSONType(goType) {
		return "" // 返回空字符串表示忽略
	}

	// 保留原始类型(包括包前缀)
	originalType := goType

	// 移除指针标记用于判断类型
	typeForCheck := strings.TrimPrefix(goType, "*")

	// 字符串类型使用Pattern
	if isStringType(typeForCheck) {
		return fmt.Sprintf("field.Pattern[%s]", originalType)
	}

	// 其他类型使用Comparable
	return fmt.Sprintf("field.Comparable[%s]", originalType)
}

// isStringType 判断是否为字符串类型
func isStringType(goType string) bool {
	stringTypes := []string{
		"string",
		"sql.NullString",
		"[]byte",
		"[]rune",
	}

	for _, t := range stringTypes {
		if goType == t {
			return true
		}
	}

	// 检查是否是text或blob类型(通常通过标签判断,这里简化处理)
	return strings.Contains(strings.ToLower(goType), "text") ||
		strings.Contains(strings.ToLower(goType), "blob")
}

// isJSONType 判断是否为JSON类型
func isJSONType(goType string) bool {
	return strings.Contains(strings.ToLower(goType), "json") ||
		goType == "datatypes.JSON" ||
		goType == "gorm.datatypes.JSON"
}

// getFieldConstructor 获取字段构造函数
func getFieldConstructor(fieldType string) string {
	if strings.Contains(fieldType, "Pattern") {
		// 提取泛型参数
		start := strings.Index(fieldType, "[")
		end := strings.Index(fieldType, "]")
		if start != -1 && end != -1 {
			typeParam := fieldType[start+1 : end]
			return fmt.Sprintf("field.NewPattern[%s]", typeParam)
		}
	}

	if strings.Contains(fieldType, "Comparable") {
		// 提取泛型参数
		start := strings.Index(fieldType, "[")
		end := strings.Index(fieldType, "]")
		if start != -1 && end != -1 {
			typeParam := fieldType[start+1 : end]
			return fmt.Sprintf("field.NewComparable[%s]", typeParam)
		}
	}

	return "field.NewComparable[any]"
}
